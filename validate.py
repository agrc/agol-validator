'''
validate.py

Usage:
    validate.py validate --org=<org> --user=<user> [--save_report=<report_path>]

Arguments:
    org           AGOL Portal to connect to [defualt: https://www.arcgis.com]
    user          AGOL User for authentication
    report_path   Folder to save report to, eg `c:\\temp`

Examples:
    validate.py validate --org=https://www.arcgis.com --user=me --save_report=c:\\temp
'''

import arcgis
import arcpy
import csv
import datetime
import getpass
import logging

from docopt import docopt

import checks


class validator:

    #: A list of log entries, format TBD
    report = []

    #: A list of feature service item objects generated by trawling all of 
    #: the user's folders
    feature_service_items = []

    #: A dictionary of folders and the item.titles in them
    folders_and_item_titles = {}

    #: A dictionary of the metatable records, indexed by the metatable's itemid
    #: values: {item_id: [table_sgid_name, table_agol_name]}
    metatable_dict = {}

    #: Tags or words that should be uppercased, saved as lower to check against
    uppercased_tags = ['2g', '3g', '4g', 'agrc', 'aog', 'at&t', 'blm', 'brat', 'caf', 'cdl', 'daq', 'dfcm', 'dfirm', 'dwq', 'e911', 'ems', 'fae', 'fcc', 'fema', 'gcdb', 'gis', 'gnis', 'hava', 'huc', 'lir', 'lrs', 'lte', 'luca', 'mrrc', 'nca', 'ng911', 'nox', 'npsbn', 'ntia', 'nwi', 'plss', 'pm10', 'psap', 'sbdc', 'sbi', 'sgid', 'sitla', 'sligp', 'trax', 'uca', 'udot', 'ugs', 'uhp', 'uic', 'us', 'usdw', 'usfs', 'usfws', 'usps', 'ustc', 'ut', 'uta', 'vcp', 'vista', 'voc']

    #: Articles that should be left lowercase.
    articles = ['a', 'the', 'of', 'is', 'in']

    #: Tags that should be deleted
    tags_to_delete = ['.sd', 'service definition']

    def __init__(self, portal, user, metatable):
        self.username = user
        self.gis = arcgis.gis.GIS(portal, user, getpass.getpass(f'{user}\'s password for {portal}:'))

        user_item = self.gis.users.me

        #: Build list of folders. 'None' gives us the root folder.
        print(f'Getting {user}\'s folders...')
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        print('Getting item objects...')
        for folder in folders:
            folder_list = []
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    self.feature_service_items.append(item)
                    folder_list.append(item.title)
            # Add item titles to folder's dictionary entry
            self.folders_and_item_titles[folder] = folder_list

        #: Read the metatable into memory as a dictionary based on itemid.
        #: Getting this once so we don't have to re-read every iteration
        print('Getting metatable info')
        with arcpy.da.SearchCursor(metatable, ['TABLENAME', 'AGOL_ITEM_ID', 'AGOL_PUBLISHED_NAME']) as table_cursor:
            for row in table_cursor:
                table_sgid_name, table_agol_itemid, table_agol_name = row
                self.metatable_dict[table_agol_itemid] = [table_sgid_name, table_agol_name]


    def validate_items(self):
        '''
        For each hosted feature layer, check:
            > Tags for malformed spacing, standard AGRC/SGID tags
                item.update({'tags':[tags]})
            > Group & Folder (?) to match source data category
                gis.content.share(item, everyone=True, groups=<Open Data Group>)
                item.move(folder)
            > Delete Protection enabled
                item.protect=True
            > Downloads enabled
                manager = arcgis.features.FeatureLayerCollection.fromitem(item).manager
                manager.update_definition({ 'capabilities': 'Query,Extract' })
            > Title against metatable
                item.update({'title':title})
            > Metadata against SGID (Waiting until 2.5's arcpy metadata tools?)

        Also, check the following:
            > Duplicate tags
        '''
        
        for item in self.feature_service_items:
            
            #: run the checks, return the correct values
            #: once we've got all the properties to be changed, run the appropriate updates

            #: Get the list of the correct tags
            tags = checks.check_tags(item, self.tags_to_delete, self.uppercased_tags, self.articles)

            #: Get the correct name, group, and folder strings
            title, group, folder = checks.get_category_and_name(item, self.metatable_dict)
        
            #: Now update if needed (be greedy; update both if only one is
            #: needed to save time calling .update() twice on occasion)
            if sorted(tags) != sorted(item.tags) or title != item.title:
                item.update({'tags':tags, 'title':title})

            

