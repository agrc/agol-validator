'''
validate.py

Usage:
    validate.py validate --org=<org> --user=<user> [--save_report=<report_path>]

Arguments:
    org           AGOL Portal to connect to [defualt: https://www.arcgis.com]
    user          AGOL User for authentication
    report_path   Folder to save report to, eg `c:\\temp`

Examples:
    validate.py validate --org=https://www.arcgis.com --user=me --save_report=c:\\temp
'''

import arcgis
import arcpy
import datetime
import getpass
import json

import pandas as pd
from docopt import docopt

import checks, fixes


class validator:

    #: A list of log entries, format TBD
    report = []

    #: A list of feature service item objects generated by trawling all of 
    #: the user's folders
    feature_service_items = []

    #: A dictionary of items and their folder
    itemid_and_folder = {}

    #: A dictionary of the metatable records, indexed by the metatable's itemid
    #: values: {item_id: [table_sgid_name, table_agol_name]}
    metatable_dict = {}

    #: Tags or words that should be uppercased, saved as lower to check against
    uppercased_tags = ['2g', '3g', '4g', 'agrc', 'aog', 'at&t', 'blm', 'brat', 'caf', 'cdl', 'daq', 'dfcm', 'dfirm', 'dwq', 'e911', 'ems', 'fae', 'fcc', 'fema', 'gcdb', 'gis', 'gnis', 'hava', 'huc', 'lir', 'lrs', 'lte', 'luca', 'mrrc', 'nca', 'ng911', 'nox', 'npsbn', 'ntia', 'nwi', 'plss', 'pm10', 'psap', 'sbdc', 'sbi', 'sgid', 'sitla', 'sligp', 'trax', 'uca', 'udot', 'ugs', 'uhp', 'uic', 'us', 'usdw', 'usfs', 'usfws', 'usps', 'ustc', 'ut', 'uta', 'vcp', 'vista', 'voc']

    #: Articles that should be left lowercase.
    articles = ['a', 'the', 'of', 'is', 'in']

    #: Tags that should be deleted
    tags_to_delete = ['.sd', 'service definition']

    def __init__(self, portal, user, metatable):
        self.username = user
        self.gis = arcgis.gis.GIS(portal, user, getpass.getpass(f'{user}\'s password for {portal}:'))

        user_item = self.gis.users.me

        #: Build list of folders. 'None' gives us the root folder.
        print(f'Getting {user}\'s folders...')
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        print('Getting item objects...')
        for folder in folders:
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    self.feature_service_items.append(item)
                    self.itemid_and_folder[item.itemid] = folder

        #: Read the metatable into memory as a dictionary based on itemid.
        #: Getting this once so we don't have to re-read every iteration
        print('Getting metatable info')
        with arcpy.da.SearchCursor(metatable, ['TABLENAME', 'AGOL_ITEM_ID', 'AGOL_PUBLISHED_NAME']) as table_cursor:
            for row in table_cursor:
                table_sgid_name, table_agol_itemid, table_agol_name = row
                self.metatable_dict[table_agol_itemid] = [table_sgid_name, table_agol_name]


    def check_items(self, report_path=None):
        '''
        For each hosted feature layer, check:
            > Tags for malformed spacing, standard AGRC/SGID tags
                item.update({'tags':[tags]})
            > Group & Folder (?) to match source data category
                gis.content.share(item, everyone=True, groups=<Open Data Group>)
                item.move(folder)
            > Delete Protection enabled
                item.protect=True
            > Downloads enabled
                manager = arcgis.features.FeatureLayerCollection.fromitem(item).manager
                manager.update_definition({ 'capabilities': 'Query,Extract' })
            > Title against metatable
                item.update({'title':title})
            > Metadata against SGID (Waiting until 2.5's arcpy metadata tools?)
        '''

        #: Dict of dicts, where outer keys are itemids and inner keys are column names
        report_dict = {}

        for item in self.feature_service_items:

            print(f'Checking {item.title}...')
            
            itemid = item.itemid

            #: Intialize emtpy dictionary for this item
            report_dict[itemid] = {}

            #: Title check
            title_data = checks.title_check(item, self.metatable_dict)
            report_dict[itemid].update(title_data)

            #: Groups check
            groups_data = checks.groups_check(item, self.metatable_dict)
            report_dict[itemid].update(groups_data)
        
            #: Folder check
            folder_data = checks.folder_check(item, self.metatable_dict, self.itemid_and_folder)
            report_dict[itemid].update(folder_data)

            #: Tags check
            tags_data = checks.tags_check(item, self.tags_to_delete, self.uppercased_tags, self.articles)
            report_dict[itemid].update(tags_data)

            #: Downloads check
            download_data = checks.downloads_check(item)
            report_dict[itemid].update(download_data)

            #: Delete Protection check
            protect_data = checks.delete_protection_check(item)
            report_dict[itemid].update(protect_data)


        if report_path:
            report_df = pd.DataFrame(report_dict).T
            report_df.to_csv(report_path)

        return(report_dict)


    def fix_items(self, report_dict):


        # report_dict = report.to_dict('index')

        results = {}

        try:
            for itemid in report_dict:

                item = self.gis.content.get(itemid)

                results[itemid] = [item.title]
                
                #: Tags and title combined .update()
                new_title = report_dict[itemid]['new_title']
                new_tags = report_dict[itemid]['new_tags']
                if new_title or new_tags:
                    results[itemid].append(fixes.tags_or_title_fix(item, new_title, new_tags))

                # update_dict = {}
                # if report_dict[itemid]['fix_title'] == 'Y':
                #     new_title = report_dict[itemid]['new_title']
                #     update_dict['title'] = new_title
                # if report_dict[itemid]['fix_tags'] == 'Y':
                #     new_tags = report_dict[itemid]['new_tags']
                #     update_dict['tags'] = new_tags
                # if update_dict:
                #     update_result = item.update(update_dict)
                #     if update_result:
                #         results[itemid].append('Tags and/or title updated')
                #     else:
                #         results[itemid].append('Failed to update tags and/or title')

                #: Group
                if report_dict[itemid]['fix_groups'] == 'Y':
                    results[itemid].append(fixes.group_fix(item, report_dict[itemid]['new_group']))
                    # new_group = report_dict[itemid]['new_group']
                    # share_results = item.share(everyone=True, groups=[new_group])
                    # success = share_results['results'][0]['success']
                    # if success:
                    #     results[itemid].append(f'Group updated to {new_group}')
                    # else:
                    #     results[itemid].append(f'Failed to update group to {new_group}')

                #: Folder
                if report_dict[itemid]['fix_folder'] == 'Y':
                    results[itemid].append(fixes.folder_fix(item, report_dict[itemid]['new_folder']))
                    # new_folder = report_dict[itemid]['new_folder']
                    # move_result = item.move(new_folder)
                    # if move_result['success']:
                    #     results[itemid].append(f'Item moved to {new_folder}')
                    # else:
                    #     results[itemid].append(f'Failed to move item to {new_folder}')

                #: Delete Protection
                if report_dict[itemid]['fix_delete_protection'] == 'Y':
                    results[itemid].append(fixes.delete_protection_fix(item))
                    # protect_result = item.protect(True)
                    # if protect_result['success']:
                    #     results[itemid].append(f'Item protected')
                    # else:
                    #     results[itemid].append(f'Failed to protect item')


                #: Enable Downloads
                if report_dict[itemid]['fix_downloads'] == 'Y':
                    results[itemid].append(fixes.downloads_fix(item))
                    # manager = arcgis.features.FeatureLayerCollection.fromitem(item).manager
                    # download_result = manager.update_definition({ 'capabilities': 'Query,Extract' })
                    # if download_result['success']:
                    #     results[itemid].append(f'Downloads enabled')
                    # else:
                    #     results[itemid].append(f'Failed to enable downloads')
        finally:
            print(results)


if __name__ == '__main__':
    # agrc = validator('https://www.arcgis.com', 'UtahAGRC', r'C:\gis\Projects\Data\internal.agrc.utah.gov.sde\SGID.META.AGOLItems')

    # agrc.check_items(r'c:\temp\validator3.csv')

    jake = validator('https://www.arcgis.com', 'Jake.Adams@UtahAGRC', r'C:\gis\Projects\Data\data.gdb\validate_test_table')

    jake_report = jake.check_items(r'c:\temp\validator2_jake.csv')
    jake.fix_items(jake_report)