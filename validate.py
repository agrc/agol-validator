'''
validate.py

Usage:
    validate.py validate --org=<org> --user=<user> [--save_report=<report_path>]

Arguments:
    org           AGOL Portal to connect to [default: https://www.arcgis.com]
    user          AGOL User for authentication
    report_path   Folder to save report to, eg `c:\\temp`

Examples:
    validate.py validate --org=https://www.arcgis.com --user=me --save_report=c:\\temp
'''

import arcgis
import arcpy
import datetime
import getpass
import json

import pandas as pd
from docopt import docopt

import checks, fixes


class validator:
    '''
    An object representing an AGOL/Portal organization and information about
    its items. Contains methods for validating and fixing various elements of
    each item's settings (name, tags, group, etc).
    '''

    #: Tags or words that should be uppercased, saved as lower to check against
    uppercased_tags = ['2g', '3g', '4g', 'agrc', 'aog', 'at&t', 'blm', 'brat', 'caf', 'cdl', 'daq', 'dfcm', 'dfirm', 'dwq', 'e911', 'ems', 'fae', 'fcc', 'fema', 'gcdb', 'gis', 'gnis', 'hava', 'huc', 'lir', 'lrs', 'lte', 'luca', 'mrrc', 'nca', 'ng911', 'nox', 'npsbn', 'ntia', 'nwi', 'plss', 'pm10', 'psap', 'sbdc', 'sbi', 'sgid', 'sitla', 'sligp', 'trax', 'uca', 'udot', 'ugs', 'uhp', 'uic', 'us', 'usdw', 'usfs', 'usfws', 'usps', 'ustc', 'ut', 'uta', 'vcp', 'vista', 'voc']

    #: Articles that should be left lowercase.
    articles = ['a', 'the', 'of', 'is', 'in']

    #: Tags that should be deleted
    tags_to_delete = ['.sd', 'service definition']

    def __init__(self, portal, user, metatables, verbose=False):
        '''
        Create an arcgis.gis.GIS object for 'user' at 'portal'. Automatically
        create a list of all the Feature Service objects in the user's folders
        and a dictionary of each item's folder based on itemid. Read 'metatable'
        into a dictionary based on the itemid.
        '''
        
        #: A list of log entries, format TBD
        self.report_dict = {}

        #: A list of feature service item objects generated by trawling all of 
        #: the user's folders
        self.feature_service_items = []

        #: A dictionary of items and their folder
        self.itemid_and_folder = {}

        #: A dictionary of the metatable records, indexed by the metatable's itemid
        #: values: {item_id: [table_sgid_name, table_agol_name]}
        self.metatable_dict = {}

        self.verbose = verbose

        self.username = user
        self.gis = arcgis.gis.GIS(portal, user, getpass.getpass(f'{user}\'s password for {portal}:'))

        user_item = self.gis.users.me

        #: Build list of folders. 'None' gives us the root folder.
        if self.verbose:
            print(f'Getting {user}\'s folders...')
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        if self.verbose:
            print('Getting item objects...')
        for folder in folders:
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    self.feature_service_items.append(item)
                    self.itemid_and_folder[item.itemid] = folder

        #: Read the metatable into memory as a dictionary based on itemid.
        #: Getting this once so we don't have to re-read every iteration
        if self.verbose:
            print('Getting metatable info...')
        duplicate_keys = []
        for metatable in metatables:
            with arcpy.da.SearchCursor(metatable, ['TABLENAME', 'AGOL_ITEM_ID', 'AGOL_PUBLISHED_NAME']) as table_cursor:
                for row in table_cursor:
                    table_sgid_name, table_agol_itemid, table_agol_name = row
                    if table_agol_itemid:  #: Don't evaluate null itemids
                        if table_agol_itemid not in self.metatable_dict:
                            self.metatable_dict[table_agol_itemid] = [table_sgid_name, table_agol_name]
                        else:
                            duplicate_keys.append(table_agol_itemid)
        
        if duplicate_keys:
            raise RuntimeError(f'Duplicate AGOL item IDs found in metatables: {duplicate_keys}')


    def check_items(self, report_path=None):
        '''
        For each hosted feature layer, check:
            > Tags for malformed spacing, standard AGRC/SGID tags
                item.update({'tags':[tags]})
            > Group & Folder (?) to match source data category
                gis.content.share(item, everyone=True, groups=<Open Data Group>)
                item.move(folder)
            > Delete Protection enabled
                item.protect=True
            > Downloads enabled
                manager = arcgis.features.FeatureLayerCollection.fromitem(item).manager
                manager.update_definition({ 'capabilities': 'Query,Extract' })
            > Title against metatable
                item.update({'title':title})
            > Metadata against SGID (Waiting until 2.5's arcpy metadata tools?)
        '''

        for item in self.feature_service_items:
            
            if self.verbose:
                print(f'Checking {item.title}...')
            
            itemid = item.itemid

            #: Initialize empty dictionary for this item
            self.report_dict[itemid] = {}

            #: Title check
            title_data = checks.title_check(item, self.metatable_dict)
            self.report_dict[itemid].update(title_data)
            #: Get the new title
            new_title = self.report_dict[itemid]['title_new']

            #: Groups check
            groups_data = checks.groups_check(item, self.metatable_dict)
            self.report_dict[itemid].update(groups_data)
        
            #: Folder check
            folder_data = checks.folder_check(item, self.metatable_dict, self.itemid_and_folder)
            self.report_dict[itemid].update(folder_data)

            #: Tags check, including new title
            tags_data = checks.tags_check(item, self.tags_to_delete, self.uppercased_tags, self.articles, new_title)
            self.report_dict[itemid].update(tags_data)

            #: Downloads check
            download_data = checks.downloads_check(item)
            self.report_dict[itemid].update(download_data)

            #: Delete Protection check
            protect_data = checks.delete_protection_check(item)
            self.report_dict[itemid].update(protect_data)

        #: Convert dict to pandas df for easy writing
        if report_path:
            report_df = pd.DataFrame(self.report_dict).T
            report_df.to_csv(report_path)


    def fix_items(self, report_path=None):
        '''
        Perform any needed fixes by looping through report dictionary and
        checking the various _fix entries. Append results string to report
        dictionary and write to report_path (if specified).
        '''

        try:
            for itemid in self.report_dict:

                item = self.gis.content.get(itemid)
                
                if self.verbose:
                    print(f'Evaluating report for fixes on {item.title}...')
                
                #: Tags and title combined .update()
                new_title = self.report_dict[itemid]['title_new']
                new_tags = self.report_dict[itemid]['tags_new']
                if new_title or new_tags:
                    tag_title_result = fixes.tags_or_title_fix(item, new_title, new_tags)
                    self.report_dict[itemid].update({'tags_title_result': tag_title_result})
                    if self.verbose:
                        print(f'\t{tag_title_result}')

                #: Group
                if self.report_dict[itemid]['groups_fix'] == 'Y':
                    groups_results = fixes.group_fix(item, self.report_dict[itemid]['group_new'])
                    self.report_dict[itemid].update({'groups_result': groups_results})
                    if self.verbose:
                        print(f'\t{groups_results}')

                #: Folder
                if self.report_dict[itemid]['folder_fix'] == 'Y':
                    folder_result = fixes.folder_fix(item, self.report_dict[itemid]['folder_new'])
                    self.report_dict[itemid].update({'folder_result': folder_result})
                    if self.verbose:
                        print(f'\t{folder_result}')

                #: Delete Protection
                if self.report_dict[itemid]['delete_protection_fix'] == 'Y':
                    delete_protection_result = fixes.delete_protection_fix(item)
                    self.report_dict[itemid].update({'delete_protection_result': delete_protection_result})
                    if self.verbose:
                        print(f'\t{delete_protection_result}')

                #: Enable Downloads
                if self.report_dict[itemid]['downloads_fix'] == 'Y':
                    downloads_result = fixes.downloads_fix(item)
                    self.report_dict[itemid].update({'downloads_result': downloads_result})
                    if self.verbose:
                        print(f'\t{downloads_result}')

        finally:
            #: Convert dict to pandas df for easy writing
            if report_path:
                report_df = pd.DataFrame(self.report_dict).T
                report_df.to_csv(report_path)


if __name__ == '__main__':
    metatables = [r'C:\gis\Projects\Data\internal.agrc.utah.gov.sde\SGID.META.AGOLItems', r'C:\gis\Projects\Data\Data.gdb\shelved_metatable']
    agrc = validator('https://www.arcgis.com', 'UtahAGRC', metatables, True)

    agrc.check_items(r'c:\temp\validator4_twotables.csv')

    # jake = validator('https://www.arcgis.com', 'Jake.Adams@UtahAGRC', r'C:\gis\Projects\Data\data.gdb\validate_test_table', True)

    # jake.check_items(r'c:\temp\validator2_jake.csv')
    # jake.fix_items(r'c:\temp\validator2_jake_fixes.csv')