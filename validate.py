'''
validate.py

Usage:
    validate.py validate --org=<org> --user=<user> [--save_report=<report_path>]

Arguments:
    org           AGOL Portal to connect to [default: https://www.arcgis.com]
    user          AGOL User for authentication
    report_path   Folder to save report to, eg `c:\\temp`

Examples:
    validate.py validate --org=https://www.arcgis.com --user=me --save_report=c:\\temp
'''

import arcgis
import arcpy
import datetime
import getpass
import json

import pandas as pd
from docopt import docopt

import checks, fixes


class validator:

    #: A list of log entries, format TBD
    report_dict = {}

    #: A list of feature service item objects generated by trawling all of 
    #: the user's folders
    feature_service_items = []

    #: A dictionary of items and their folder
    itemid_and_folder = {}

    #: A dictionary of the metatable records, indexed by the metatable's itemid
    #: values: {item_id: [table_sgid_name, table_agol_name]}
    metatable_dict = {}

    #: Tags or words that should be uppercased, saved as lower to check against
    uppercased_tags = ['2g', '3g', '4g', 'agrc', 'aog', 'at&t', 'blm', 'brat', 'caf', 'cdl', 'daq', 'dfcm', 'dfirm', 'dwq', 'e911', 'ems', 'fae', 'fcc', 'fema', 'gcdb', 'gis', 'gnis', 'hava', 'huc', 'lir', 'lrs', 'lte', 'luca', 'mrrc', 'nca', 'ng911', 'nox', 'npsbn', 'ntia', 'nwi', 'plss', 'pm10', 'psap', 'sbdc', 'sbi', 'sgid', 'sitla', 'sligp', 'trax', 'uca', 'udot', 'ugs', 'uhp', 'uic', 'us', 'usdw', 'usfs', 'usfws', 'usps', 'ustc', 'ut', 'uta', 'vcp', 'vista', 'voc']

    #: Articles that should be left lowercase.
    articles = ['a', 'the', 'of', 'is', 'in']

    #: Tags that should be deleted
    tags_to_delete = ['.sd', 'service definition']

    def __init__(self, portal, user, metatable):
        self.username = user
        self.gis = arcgis.gis.GIS(portal, user, getpass.getpass(f'{user}\'s password for {portal}:'))

        user_item = self.gis.users.me

        #: Build list of folders. 'None' gives us the root folder.
        print(f'Getting {user}\'s folders...')
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        print('Getting item objects...')
        for folder in folders:
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    self.feature_service_items.append(item)
                    self.itemid_and_folder[item.itemid] = folder

        #: Read the metatable into memory as a dictionary based on itemid.
        #: Getting this once so we don't have to re-read every iteration
        print('Getting metatable info')
        with arcpy.da.SearchCursor(metatable, ['TABLENAME', 'AGOL_ITEM_ID', 'AGOL_PUBLISHED_NAME']) as table_cursor:
            for row in table_cursor:
                table_sgid_name, table_agol_itemid, table_agol_name = row
                self.metatable_dict[table_agol_itemid] = [table_sgid_name, table_agol_name]


    def check_items(self, report_path=None):
        '''
        For each hosted feature layer, check:
            > Tags for malformed spacing, standard AGRC/SGID tags
                item.update({'tags':[tags]})
            > Group & Folder (?) to match source data category
                gis.content.share(item, everyone=True, groups=<Open Data Group>)
                item.move(folder)
            > Delete Protection enabled
                item.protect=True
            > Downloads enabled
                manager = arcgis.features.FeatureLayerCollection.fromitem(item).manager
                manager.update_definition({ 'capabilities': 'Query,Extract' })
            > Title against metatable
                item.update({'title':title})
            > Metadata against SGID (Waiting until 2.5's arcpy metadata tools?)
        '''

        #: Dict of dicts, where outer keys are itemids and inner keys are column names
        # report_dict = {}

        for item in self.feature_service_items:

            print(f'Checking {item.title}...')
            
            itemid = item.itemid

            #: Initialize empty dictionary for this item
            self.report_dict[itemid] = {}

            #: Title check
            title_data = checks.title_check(item, self.metatable_dict)
            self.report_dict[itemid].update(title_data)
            #: Get the new title
            new_title = self.report_dict[itemid]['new_title']

            #: Groups check
            groups_data = checks.groups_check(item, self.metatable_dict)
            self.report_dict[itemid].update(groups_data)
        
            #: Folder check
            folder_data = checks.folder_check(item, self.metatable_dict, self.itemid_and_folder)
            self.report_dict[itemid].update(folder_data)

            #: Tags check, including new title
            tags_data = checks.tags_check(item, self.tags_to_delete, self.uppercased_tags, self.articles, new_title)
            self.report_dict[itemid].update(tags_data)

            #: Downloads check
            download_data = checks.downloads_check(item)
            self.report_dict[itemid].update(download_data)

            #: Delete Protection check
            protect_data = checks.delete_protection_check(item)
            self.report_dict[itemid].update(protect_data)

        #: Convert dict to pandas df for easy writing
        if report_path:
            report_df = pd.DataFrame(self.report_dict).T
            report_df.to_csv(report_path)


    def fix_items(self, report_path=None):


        try:
            for itemid in self.report_dict:

                item = self.gis.content.get(itemid)
                
                #: Tags and title combined .update()
                new_title = self.report_dict[itemid]['new_title']
                new_tags = self.report_dict[itemid]['new_tags']
                if new_title or new_tags:
                    tag_title_result = fixes.tags_or_title_fix(item, new_title, new_tags)
                    self.report_dict[itemid].update({'tag_title_result': tag_title_result})

                #: Group
                if self.report_dict[itemid]['fix_groups'] == 'Y':
                    group_results = fixes.group_fix(item, self.report_dict[itemid]['new_group'])
                    self.report_dict[itemid].update({'group_result': group_results})

                #: Folder
                if self.report_dict[itemid]['fix_folder'] == 'Y':
                    folder_result = fixes.folder_fix(item, self.report_dict[itemid]['new_folder'])
                    self.report_dict[itemid].update({'folder_result': folder_result})

                #: Delete Protection
                if self.report_dict[itemid]['fix_delete_protection'] == 'Y':
                    delete_protection_result = fixes.delete_protection_fix(item)
                    self.report_dict[itemid].update({'delete_protection_result': delete_protection_result})

                #: Enable Downloads
                if self.report_dict[itemid]['fix_downloads'] == 'Y':
                    downloads_result = fixes.downloads_fix(item)
                    self.report_dict[itemid].update({'downloads_result': downloads_result})

        finally:
            #: Convert dict to pandas df for easy writing
            if report_path:
                report_df = pd.DataFrame(self.report_dict).T
                report_df.to_csv(report_path)



if __name__ == '__main__':
    # agrc = validator('https://www.arcgis.com', 'UtahAGRC', r'C:\gis\Projects\Data\internal.agrc.utah.gov.sde\SGID.META.AGOLItems')

    # agrc.check_items(r'c:\temp\validator3.csv')

    jake = validator('https://www.arcgis.com', 'Jake.Adams@UtahAGRC', r'C:\gis\Projects\Data\data.gdb\validate_test_table')

    jake.check_items(r'c:\temp\validator2_jake.csv')
    jake.fix_items(r'c:\temp\validator2_jake_fixes.csv')